@page "/"
@using Velo.Classes
@inject IJSRuntime JS

@using System.Globalization

<div class="container-fluid vh-100 overflow-hidden velo-bg d-flex flex-column" @ref="dropZoneElement">
    <div class="init-desc" style="pointer-events: none;">Select or drop an image to start</div>

    <div class="velo-header p-3 d-flex align-items-center justify-content-between">
        <div class="upload-zone" style="width: 500px;">
            <input type="file" @onchange="OnFilesSelected" @ref="fileInputRef" id="fileInput" multiple
                class="select-files" />
        </div>
        <h2 class="mb-0 flex-grow-1 text-center"><img src="VeloLogoText.svg" alt="VELO" style="height: 80px; pointer-events: none;" /></h2>
        <div style="width: 500px;" class="d-flex justify-content-end">

        </div>
    </div>
    <div class="row h-100 flex-grow-1">
        <div class="col-3 velo-bg p-3 overflow-auto">

            @if (pendingFiles.Any())
            {
                <div class="d-flex justify-content-between align-items-center mb-3" style="height: 30px;">
                    <h5 class="text-muted small text-uppercase mb-0">Selected files (@pendingFiles.Count)</h5>
                    <div>
                        <button class="btn btn-danger btn-sm" @onclick="ClearAllFiles">🗑️ Clear All</button>
                        <button class="btn btn-success btn-sm" @onclick="DownloadZip">📦 ZIP</button>
                    </div>
                </div>

                @foreach (var file in pendingFiles)
                {
                    <div class="file-row p-3 mb-2 rounded @(selectedFile == file ? "border-primary shadow-glow" : "border-secondary")"
                        @onclick="() => SelectFile(file)">

                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <div class="text-truncate" style="max-width: 75%;">
                                <div class="text-white fw-bold small">@file.Name</div>
                                <div class="mt-1">
                                    <small class="text-muted">Before: @FormatSize(file.Size / 1024.0)</small>
                                    @if (file.CompressedSize.HasValue)
                                    {
                                        bool isLarger = file.CompressedSize.Value > (file.Size / 1024.0);
                                        <small class="@(isLarger ? "text-danger" : "text-success") fw-bold ms-2">
                                            After: @FormatSize(file.CompressedSize.Value)
                                            @if (file.Savings.HasValue)
                                            {
                                                <span>(@(file.Savings.Value >= 0 ? $"-{file.Savings.Value:F1}%" :
                                                                                        $"+{Math.Abs(file.Savings.Value):F1}%"))</span>
                                            }
                                        </small>
                                    }
                                </div>
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm text-info p-0" @onclick:stopPropagation="true"
                                    @onclick="() => ResetQuality(file)">⟳</button>
                                <button class="btn btn-sm text-danger p-0" @onclick:stopPropagation="true"
                                    @onclick="() => RemoveFile(file)">✕</button>
                            </div>
                        </div>

                        <div class="row align-items-center g-2 border-top border-secondary pt-2 mt-1">
                            <div class="col">
                                <input type="range" class="form-range" min="1" max="100" step="1" value="@file.Quality"
                                    @oninput="(e) => UpdateQualityValue(e, file)" @onchange="() => OptimizeSingleFile(file)"
                                    @onclick:stopPropagation="true" />
                            </div>
                            <div class="col-auto">
                                <span class="badge bg-primary" style="font-size: 0.6rem;">@file.Quality%</span>
                            </div>
                        </div>
                    </div>
                }
            }
        </div>

        <div class="col-9 p-0 d-flex flex-column h-100 position-relative">
            @if (selectedFile != null)
            {
                <div class="p-2 d-flex justify-content-between align-items-center">
                    <div class="ps-2 preview-title" style="height: 30px;">
                        <span class="small" style="color: #6c757d; text-transform: uppercase !important;">Optimization
                            preview</span>
                    </div>
                    @* @if (selectedFile.Savings.HasValue)
                    {
                        var s = selectedFile.Savings.Value;
                        <span class="badge border @(s >= 0 ? "border-success text-success" : "border-danger text-danger") me-2">
                            @(s >= 0 ? $"Reduction: -{s:F1}%" : $"Increase: +{Math.Abs(s):F1}%")
                        </span>
                    } *@
                </div>

                <div class="preview-stage @(selectedFile != null ? "border border-primary shadow-glow" : "")">
                    @if (!string.IsNullOrEmpty(selectedFile.Url))
                    {
                        <div class="velo-container" @ref="veloContainerRef" tabindex="0">
                            <div class="zoom-controls">
                                <button class="zoom-btn before-btn @(showingOriginal ? "active" : "")"
                                    @onclick="() => showingOriginal = true" title="Show Before">Before</button>
                                <button class="zoom-btn after-btn @(showingOriginal ? "" : "active")"
                                    @onclick="() => showingOriginal = false" title="Show After">After</button>
                            </div>

                            <div class="zoom-frame">
                                <img src="@selectedFile.OriginalUrl" class="frame-img original-image" draggable="false"
                                    style="display: @(showingOriginal ? "block" : "none");" />
                                <img src="@selectedFile.Url" class="frame-img optimized-image" draggable="false"
                                    style="display: @(showingOriginal ? "none" : "block");" />
                            </div>
                        </div>
                    }
                </div>
            }
            else
            {
            }
        </div>
    </div>
</div>

@code {
    private bool isProcessing = false;
    private ElementReference dropZoneElement;
    private ElementReference fileInputRef;
    private List<FileEntry> pendingFiles = new();

    private FileEntry? selectedFile;
    private ElementReference veloContainerRef;
    private string? lastZoomInitFileId;
    private bool showingOriginal = false;


    private void SelectFile(FileEntry file)
    {
        selectedFile = file;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("enableDragDrop", dropZoneElement, fileInputRef);
        }

        if (selectedFile != null && selectedFile.FileId != lastZoomInitFileId)
        {
            await JS.InvokeVoidAsync("previewZoom.init", veloContainerRef);
            lastZoomInitFileId = selectedFile.FileId;
        }
    }

    private async Task ZoomIn()
    {
        await JS.InvokeVoidAsync("previewZoom.zoomIn", veloContainerRef);
    }

    private async Task ZoomOut()
    {
        await JS.InvokeVoidAsync("previewZoom.zoomOut", veloContainerRef);
    }

    private async Task ResetZoom()
    {
        await JS.InvokeVoidAsync("previewZoom.reset", veloContainerRef);
    }

    private async Task OnFilesSelected(ChangeEventArgs e)
    {
        var newFiles = await JS.InvokeAsync<List<FileEntry>>("getSelectedFilesInfo", fileInputRef);

        foreach (var file in newFiles)
        {
            // Check if file with same name already exists in pendingFiles
            if (pendingFiles.Any(f => f.Name == file.Name))
            {
                Console.WriteLine($"File {file.Name} is already in the list");
                continue;
            }

            file.Quality = 75;

            // Ora l'ID esiste sicuramente in cache
            file.OriginalUrl = await JS.InvokeAsync<string>("getFileUrl", file.FileId);

            pendingFiles.Add(file);
            if (selectedFile == null) selectedFile = file;

            // Eseguiamo l'ottimizzazione
            await OptimizeSingleFile(file);
        }

        // Reset the file input so the user can select more files
        await JS.InvokeVoidAsync("clearFileInput", fileInputRef);

        StateHasChanged();
    }


    private async Task StartConversion()
    {
        if (!pendingFiles.Any()) return;
        isProcessing = true;

        foreach (var file in pendingFiles)
        {
            await OptimizeSingleFile(file);
        }

        isProcessing = false;
        StateHasChanged();
    }

    private async Task OptimizeSingleFile(FileEntry file)
    {
        try
        {
            var res = await JS.InvokeAsync<NativeResult>("compressNativeVelo", file.FileId, file.Quality);

            file.Url = res.Url;
            file.Data = res.Data;
            file.CompressedSize = res.Data.Length / 1024;
            file.Savings = Math.Round(100 - ((double)res.Data.Length / res.OrigSize * 100), 1);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Errore su {file.Name}: {ex.Message}");
        }
    }

    private async Task RemoveFile(FileEntry file)
    {
        // 1. Chiamiamo il JS per pulire la RAM
        await JS.InvokeVoidAsync("removeFromCache", file.FileId);

        // 2. Rimuoviamo dalla lista C#
        pendingFiles.Remove(file);

        // 3. Se il file rimosso era quello selezionato, azzeriamo l'anteprima
        if (selectedFile == file)
        {
            selectedFile = pendingFiles.FirstOrDefault();
        }

        StateHasChanged();
    }

    private async Task ClearAllFiles()
    {
        // Pulizia della memoria per tutti i file
        foreach (var file in pendingFiles)
        {
            await JS.InvokeVoidAsync("removeFromCache", file.FileId);
        }

        // Svuota la lista
        pendingFiles.Clear();
        selectedFile = null;

        StateHasChanged();
    }

    private async Task DownloadZip()
    {
        var zipPayload = pendingFiles.Where(f => f.Data != null).Select(r => new
        {
            fileName = r.Name,
            data = Convert.ToBase64String(r.Data!)
        }).ToList();

        var json = System.Text.Json.JsonSerializer.Serialize(zipPayload);
        await JS.InvokeVoidAsync("downloadAsZip", json);
    }

    private async Task ResetQuality(FileEntry file)
    {
        // Resetta la qualità al valore di default (75)
        file.Quality = 75;

        // Riesegue l'ottimizzazione per aggiornare il peso del file
        await OptimizeSingleFile(file);

        StateHasChanged();
    }

    private void UpdateQualityValue(ChangeEventArgs e, FileEntry file)
    {
        if (int.TryParse(e.Value?.ToString(), out var newVal))
        {
            file.Quality = newVal;
            // Aggiorna solo il numero nella UI della lista
        }
    }

    private string FormatSize(double? sizeInKb)
    {
        if (!sizeInKb.HasValue) return "-";

        // Se è maggiore o uguale a 1024 KB, lo mostriamo in MB
        if (sizeInKb >= 1024)
        {
            return (sizeInKb.Value / 1024.0).ToString("N2", System.Globalization.CultureInfo.CurrentCulture) + " MB";
        }

        // Altrimenti lo mostriamo in KB
        return sizeInKb.Value.ToString("N0", System.Globalization.CultureInfo.CurrentCulture) + " KB";
    }


}